---
title: "Redis八股"
description: 一些背诵的记忆
date: 2023-09-22T18:53:45+08:00
image: 
math: 
license: 
hidden: false
comments: true
draft: false
---
一些八股

## redis为什么快

1. Redis都是基于内存，内存的访问速度是磁盘的千万倍
2. Redis基于Reactor模式开发一套高效的事件处理模型，主要单线程时间循环和IO多路复用。
3. Redis内存内置很多优化过后的数据结构实现，性能很高。

![why-redis-so-fast](https://img-1312072469.cos.ap-nanjing.myqcloud.com/why-redis-so-fast-d3507ae8.png)

## 为什么要用Redis做缓存

1. 高性能
2. 高并发

## 请你简单说说Redis的内存结构

### 基本数据结构

- String
- List
- Set
- Hash
- Zset

#### String

这种数据结构普是最常见的，用与存储对应的数据比如字符串、整数、浮点数、图片（图片的baser64鞭名马或者解码或者图片的路径）、序列化的对象。

Redis虽然采用C语言编写，当时Redis再使用String的时候没有使用C语言的String类，而是在及创建了一种简单动态字符串（SDS)。相比于原本的 S提让 结构，获取自负床长度时间复杂度位O(1)。除此之外，Redis的SDS API是安全的，不会造成缓冲区溢出。

应用场景：

- 常规数据（比如session、token、序列化后的对象、图片的路径）的缓存；
- 计数比如用户单位时间的请求书（简单限流可以用到）、页面单位时间的访问数
- 分布式锁

#### List

List（列表），就是采用最基本的链式数据结构进行实现，这个的话采用就是一个单链表，没有什么好讲的。

#### Hash

这个数据结构适用于存储对象，后续操作的时候，可以直接修改这个对象。

#### Set

存储的值都是唯一的，这个适用于实现交集、并集、差集的操作，例如将一个用户所有关注人窜在一个集合中，将其所有粉丝存放在一个结合，这样，Set可以很好的实现共同管、共同粉丝、共同喜功能，这个过程就是再求交集的过程。

使用场景：

- 网站重复UV统计、文章点赞、动态点赞等等
- 需要获取多个数据交集、丙级和差集的场景：共同好友（交集）、共同关注（交集）、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集）等等
- 需要随机获取数据源中元素的场景：抽奖系统、随机点名。

#### Sort Set

相机爱与Set 增加可一个权重参数sorce，是的集合中的元素能够按照score进行有序排列，还可以通过score的范围来获取元素的列表。有点像HashMap与TreeSet的结合体。

### 特殊数据结构

#### Bitmap

Bitmap存储的是连续的二进制数字，通过Bitmap，只需要一个bit位来表示某个元素对应的值或者状态，key就是对应元素本身，8bit可以组成一个byte，所以bitmap本身会极大的节省存储空间。

#### HyperLogLog

HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。

Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：

- **稀疏矩阵**：计数较少的时候，占用空间很小。
- **稠密矩阵**：计数达到某个阈值的时候，占用 12k 的空间。

应用场景：

**数量量巨大（百万、千万级别以上）的计数场景**

- 举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、
- 相关命令：`PFADD`、`PFCOUNT` 。

#### Geospatial index

Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。

通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。

应用场景：

**需要管理使用地理空间数据的场景**

- 举例：附近的人。
- 相关命令: `GEOADD`、`GEORADIUS`、`GEORADIUSBYMEMBER` 。

## String进行存储好还是使用Hash存储好

- String存储的是序列的对象，存放的是整个对象。 Hash是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要淡出查询对象中的个别信息，Hash就非常合适。
- String存储相对来说更加节省内存，缓存相同数量的对象数据，String消耗的内存是Hash的一眼，，并且，存储具有多层嵌套的对象也方便很多。如果系统对性能和资源非常敏感的话，String就非常适合。

因此，在绝大部分场景中，使用String来存储对象即可。

## String的底层是采用什么进行实现的

String底层采用了自己实现的SDS结构进行实现。

SDS结构体定义如下:

```c
/*
 * 保存字符串对象的结构
 */

//这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，
//len 和 free 的定义用了 4 个字节，造成了浪费。
//Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。

struct sdshdr {
    
    // buf 中已占用空间的长度
    //记录buf数组中已经使用自己的数量
    // 等于SDS所保存字符串的长度
    int len;

    // buf 中剩余可用空间的长度
    // 记录buf数组中未使用字节的数量
    int free;

    // 数据空间
    // 字节数组，用于保存字符串
    char buf[];
};
```

![](https://img-1312072469.cos.ap-nanjing.myqcloud.com/20230417112227.png)

<font color ="red">SDS遵循C字符串以空字符结尾的惯例</font>，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，SDS可以直接重用一部分C字符串函数库里面的函数。

与C的区别：

主要区别就是在线长度统计，SDS可以常熟复杂度获取字符串长度。

SDS可以杜绝空间  进行溢出，在进行实现的 时候采用下面的步骤 ：

1. 首先检查SDS空间是否满足修改 所需的要求，如果不满足的话，API会自动将SDS的空间罗战至执行修改所需的带线啊哦，然后才执行实际的修改操作。
2. 使用sdsact进行拼接操作，扩容出对应的空间

减少内存分配次数：SDS采用空间预分配和惰性空间释放两种优化策略。当SDS需要增加字符串 时，Redis会为SDS分配好内存，并且根据特定算法分配多余的内存，这样可以减少 连续执行字符串增长操作所需的内存分配次数。当减少字符串时，这部分不会劣迹被回收，会被记录下再来，等待后续使用

进制安全：SDS在使用的收可以直接使用内存，然后就会出现读到\0的情况。

## 请你简单说说Redis持久化（重要）

三种持久化方式：

1. 快照（RDB）
2. 只追加文件（AOF）
3. RDB 和 AOF 的混合持久化(Redis 4.0 新增)

### RDB持久化

创建快照来获取存储在内存里面的数据在某个时间点上的副本，Redis创建快照之后，可以对快照进行备份，可以升降快照复制到其他服务器从而创建具有形同数据的服务器副本，还可以将快照留在原地一边重启服务器的时候进行使用。

快照持久化是 Redis 默认采用的持久化方式

### RDB创建快照的时候会阻塞主线程吗

Redis提供两个命令生成RDB快照文件：

- save：同步保存操作，会阻塞Redis主线程
- bgsave：fork出一个子进程，子进行执行，不会阻塞Redis主线程，默认此选项。

### AOF持久化

与快照持久化相比，AOF 持久化的实时性更好。

开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 `server.aof_buf` 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ `fsync`策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。

#### AOF工作基本流程

1. 命令追加（append）：所有写明回追较大AOF缓冲区中
2. 命令写入（write）：将AOF缓冲区的数据写入到AOF文件中，这一不需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回（延迟写）。**此时没有同步到磁盘。**
3. 文件同步（fsync）：AOF缓冲区根据对应的持久化 方式（fsync策略）像磁盘中做同步操作。这异步需要调用 `fsync` 函数（系统调用）， `fsync` 针对单个文件操作，对其进行强制硬盘同步，`fsync` 将阻塞直到写入磁盘完成后返回，保证了数据持久化。
4. **文件重写（rewrite）**：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。
5. **重启加载（load）**：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。

![AOF 工作基本流程](https://oss.javaguide.cn/github/javaguide/database/redis/aof-work-process.png)

#### AOF持久化方式

1. `appendfsync always`：主线程调用 `write` 执行写操作后，后台线程（ `aof_fsync` 线程）立即会调用 `fsync` 函数同步 AOF 文件（刷盘），`fsync` 完成后线程返回，这样会严重降低 Redis 的性能（`write` + `fsync`）。
2. `appendfsync everysec`：主线程调用 `write` 执行写操作后立即返回，由后台线程（ `aof_fsync` 线程）每秒钟调用 `fsync` 函数（系统调用）同步一次 AOF 文件（`write`+`fsync`，`fsync`间隔为 1 秒）
3. `appendfsync no`：主线程调用 `write` 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（`write`但不`fsync`，`fsync` 的时机由操作系统决定）。

可以看出：**这 3 种持久化方式的主要区别在于 `fsync` 同步 AOF 文件的时机（刷盘）**。

#### AOF为什么是在执行玩命令之后记录日志

关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。

![AOF 记录日志过程](https://oss.javaguide.cn/github/javaguide/database/redis/redis-aof-write-log-disc.png)

**为什么是在执行完命令之后记录日志呢？**

- 避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；
- 在命令执行完之后再记录，不会阻塞当前的命令执行。

这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：

- 如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；
- 可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。

#### AOF重写

![AOF 重写](https://oss.javaguide.cn/github/javaguide/database/redis/aof-rewrite.png)

AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。

AOF 文件重写期间，Redis 还会维护一个 **AOF 重写缓冲区**，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。

开启 AOF 重写功能，可以调用 `BGREWRITEAOF` 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：

- `auto-aof-rewrite-min-size`：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;
- `auto-aof-rewrite-percentage`：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。

#### AOF校验机制

AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 **校验和（checksum）** 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。

### 如何选择RDB和AOF

Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。

不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。

如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。

## Redis线程模型（shenyu也是用这个 Netty也是用这个 这个搞懂）

Redis基于Reactor模式设计开发一套搞笑的时间处理模型。这个时间处理模型对应的是Redis中的文件事件处理器。由于文件时间处理器（file event handler）是单线程方式运行的，所以我们一般都说Redis是单线程模型。

Reactor单线程模型采用的是下面这种方式：

![img](https://img-1312072469.cos.ap-nanjing.myqcloud.com/v2-e8baaf6a534a0f31e2108aab37103842_b.jpg)

1、Reactor对象通过select监听客户端请求事件，收到事件后，通过dispatch进行分发。

2、如果建立连接请求，则Acceptor通过accept处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件。

3、如果不是连接请求，则由reactor分发调用连接对应的handler来处理。

4、handler只负责相应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务。

5、worker线程池会分配独立线程完成真正的业务，并将结果返回给handler。

6、handler收到响应后，通过send分发将结果返回给client。

**虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字**，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。

### **既然是单线程，那怎么监听大量的客户端连接呢？**

Redis 通过 **IO 多路复用程序** 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。

这样的好处非常明显：**I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗**（和 NIO 中的 `Selector` 组件很像）。

文件事件处理器（file event handler）主要是包含 4 个部分：

- 多个 socket（客户端连接）
- IO 多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将 socket 关联到相应的事件处理器）
- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

![文件事件处理器（file event handler）](https://img-1312072469.cos.ap-nanjing.myqcloud.com/redis-event-handler.png)

## Redis事务

**Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。**

Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。

除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。

因此，Redis 事务是不建议在日常开发中使用的。

Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。

，Redis 支持持久化，而且支持 3 种持久化方式:

- 快照（snapshotting，RDB）
- 只追加文件（append-only file, AOF）
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)

## Redis性能优化

### 使用批量操作减少网络传输

1. 发送命令
2. 命令排队
3. 命令执行
4. 返回结果

#### pipeline

####  Lua 脚本

### 大量 key 集中过期问题

对于过期 key，Redis 采用的是 **定期删除+惰性/懒汉式删除** 策略。

定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。

**如何解决呢？** 下面是两种常见的方法：

1. 给 key 设置随机过期时间。
2. 开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。

个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间

### Redis bigkey（大 Key）

即为key对应value占用空间很大。

bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。

### Redis hotkey（热 Key）

访问次数多于其他。那这个 key 就可以看作是 hotkey。

hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。

处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。

**读写分离**：主节点处理写请求，从节点处理读请求。

**使用 Redis Cluster**：将热点数据分散存储在多个 Redis 节点上。

**二级缓存**：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。

### 慢查询

执行时间很长的语句。

### Redis内存碎片

产生内存碎片的原因：

**1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。**

**2、频繁修改 Redis 中的数据也会产生内存碎片。**

清理内存碎片：

1. 直接通过 `config set` 命令将 `activedefrag` 配置项设置为 `yes` 即可。
2. 通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：

```shell
# 内存碎片清理所占用 CPU 时间的比例不低于 20%
config set active-defrag-cycle-min 20
# 内存碎片清理所占用 CPU 时间的比例不高于 50%
config set active-defrag-cycle-max 50
```

3. 重启节点可以做到内存碎片重新整理。

## 缓存穿透

简单说，就是大量的key同时进行访问，这个时候直接没有经过redis，直接访问对应的数据库，造成数据库访问压力。

![缓存穿透](https://img-1312072469.cos.ap-nanjing.myqcloud.com/redis-cache-penetration.png)

如何解决？

1. **缓存无效 key**
   - 如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：`SET key value EX 10086` 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。
2. **布隆过滤器**
   - 把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

![加入布隆过滤器之后的缓存处理流程图](https://oss.javaguide.cn/github/javaguide/database/redis/redis-cache-penetration-bloom-filter.png)

**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

## 缓存击穿

缓存击穿就是同一时刻一个热点key进行访问的时候，此时这个key失效，直接访问对应的数据库。

![缓存击穿](https://img-1312072469.cos.ap-nanjing.myqcloud.com/redis-cache-breakdown.png)

解决办法：

1. 设置热点数据永不过期或者过期时间比较长。
2. 针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。
3. 请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。

缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。

缓存击穿中，请求的 key 对应的是 **热点数据** ，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）** 。

## 缓存雪崩

**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。**

![缓存雪崩](https://img-1312072469.cos.ap-nanjing.myqcloud.com/redis-cache-avalanche.png)

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效（不太推荐，实用性太差）。
3. 设置二级缓存。

缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。

## 如何保证缓存和数据库数据的一致性？

**缓存失效时间变短（不推荐，治标不治本）**：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。

**增加 cache 更新重试机制（常用）**：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。

其实这个和shenyu中二级缓存有点相似。

## Redis如何实现限流算法

### 用redis令牌桶算法进行限流

- 系统以恒定的速率产⽣令牌，然后将令牌放⼊令牌桶中。
- 令牌桶有⼀个容量，当令牌桶满了的时候，再向其中放⼊的令牌就会被丢弃。
- 每次⼀个请求过来，需要从令牌桶中获取⼀个令牌，如果有令牌，则提供服务；如果没有令牌，则拒绝服务。

- 流程图： 

![img](https://img-1312072469.cos.ap-nanjing.myqcloud.com/tokenbucket-a11a51776844dc57cb9ba82904dc4ca6.png)

### 采用redis漏桶算法进行限流

- ⽔（请求）先进⼊到漏桶⾥，漏桶以⼀定的速度出⽔，当⽔流⼊速度过⼤会直接溢出（拒绝服务）

- 流程图： ![img](https://img-1312072469.cos.ap-nanjing.myqcloud.com/leakybucket-cc829d5529e0847152a90793867e9f96.png)

### 基于redis实现的滑动窗口算法

- 滑动时间窗口通过维护⼀个单位时间内的计数值，每当⼀个请求通过时，就将计数值加1，当计数值超过预先设定的阈值时，就拒绝单位时间内的其他请求。如果单位时间已经结束，则将计数器清零，开启下⼀轮的计数。

- 算法图：

![img](https://img-1312072469.cos.ap-nanjing.myqcloud.com/huadongwindow-26a67dc9b1cc954375a3e4a3bfc56d59.jpg)

程图： ![img](https://img-1312072469.cos.ap-nanjing.myqcloud.com/sldingwindow-c529b50727afb275845585edb72b0215.png)
